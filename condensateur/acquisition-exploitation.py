import serial
import time
import matplotlib.pyplot as plt
import numpy as np

# avant de compiler ce programme, RESET de la carte pour la placer en état de pré-charge condo

# variables pour étude théorique 
R = 270
C = 100e-6
tau = R*C
tau_us = tau*1e6# tau en microsecondes

######################################
# fichier d'enregistrement des données
######################################
file=open("data", "w")# ouverture du fichier pour enregistrement données
file.write("#temps;charge")# incipit du fichier
file.write("\n")# retour à la ligne

#########################
# ouverture du port série
#########################
# avec adressage (en bas à droite IDE arduino + vitesse (idem code arduino)
port_serie = serial.Serial(port = "/dev/ttyACM0",baudrate = 115200)

####################################################
# envoi donnée à arduino pour déclencher acquisition
####################################################
lettre = input("Pour lancer l'acquisition, taper une lettre et valider : ")
#on envoie sur port série mais d'abord on transforme en bytes comme tt ce qui sort/entre du port série pour Python
port_serie.write(lettre.encode("ascii"))

#################################################################
# réception des données en provenance de l'arduino via port série
# placement dans des listes, enregistrement dans un fichier
#################################################################
temps, charge = [], []
fin = False # À COMPLÉTER
duree_reception_python = 10*tau_us# en microsecondes // plus petit que le temps choisi sur Arduino

while (fin == False or (temps[-1]-temps[0]) <= duree_reception_python):
    ligne_recue = port_serie.readline()#ligne reçue b'.....\r\n' donc en bytes
    ligne_recue_str = ligne_recue.decode("ascii")#on trsf en str
    ligne_recue_str_list = ligne_recue_str.split(";")#on crée une liste en spécifiant que le séparateur est ;
    try :
        print(ligne_recue_str_list)# affichage en console
        t = float(ligne_recue_str_list[0])#on pd 1ère valeur de liste qui est un string en le transformant en float
        c = float(ligne_recue_str_list[1])#on prend 2ème valeur de liste qui est un string en le transformant en float
        temps.append(t)
        charge.append(c)
        fin = True
        #on ecrit dans un fichier csv pour svgd la ligne transformée de bytes en string
        file.write(ligne_recue_str)
    except :
        pass
    fin=True

#################################        
# fermeture fichier et port série    
#################################
file.close()
port_serie.close()

########################################
# un peu d'attente ne fait jamais de mal 
########################################
time.sleep(2)# du délai pour laisser le port série tranquille
# sinon ça plante entre 2 compilations qui se suivent vite
print("terminé")
time.sleep(2)#idem que précédemment

#####################################
# représentation points expérimentaux
#####################################
plt.plot(temps,charge, 'b+', label = "points expérimentaux")

#################
# étude théorique
#################
# autre variable
ChargeMax = 100

# calcul de la courbe théorique
temps = np.array(temps) # on transforme temps en array pour calcul suivant : 
charge_theorie = ChargeMax*(1-np.exp(-temps/tau_us))

# représentation courbe théorique
plt.plot(temps, charge_theorie, 'r--', label = "courbe théorique")

plt.xlabel("temps (ms)")
plt.ylabel("charge")
plt.title("Circuit RC série, charge du condensateur, R = {r}$\\;\\Omega$ ; C = {c} F".format(r=R, c=C))
plt.grid()
plt.legend()
plt.show()
